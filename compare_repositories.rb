#!/usr/bin/env ruby
#
# == Synopsis
#   Script to compmare the reports generated by the checker from the same repository 
#   in two different places. Script will confirm 
#        - All the documents on one server are on the other, with the same hashes
#        - All the documents on one server are on the other, with the same hashes
#
#   Note this requires the report files to be in .csv format. Using JSON would introduce a 
#   Gem dependancy , which we like to avoid
#
# == Examples
#
#     ruby compare_repositories.rb /path/to/reports/directory1/path/to/reports/directory2
#
# == Usage
#   compare_repositories.rb [options] /path/to/reports/directory1/path/to/reports/directory2
#
#   For help use: ruby compare_repositories.rb -h
#
# == Options
#   -h, --help          Displays help message
#
# == Author
#   Amphora Research Systems, Ltd.
#
# == Copyright
#   Copyright (c) 2012 Amphora Research Systems Ltd.
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# ================================================================================================================
# Yes, I know this could be more compact code, but I'm writing for transparency here... people reading this code
# might not be Ruby native
# ================================================================================================================



# Things we need to process command line arguments
require 'optparse'
require 'ostruct'

# For importing the .csv files
require 'csv'

# Logging
require 'logger'


# setup our logger STDOUT for now
LOG = Logger.new(STDOUT)
# Only report errors
LOG.level = Logger::ERROR

# This is pretty much copied from the pscheck.rb file
class RepositoryComparer
  attr_reader :options

  def initialize(arguments, stdin)
    @arguments = arguments
    @stdin = stdin

    # set defaults
    @options = OpenStruct.new

  end

  # Parse options, check arguments, then process the command
  def run
    if parsed_options? && arguments_valid?
      if @options.verbose
        LOG.level = Logger::INFO
      elsif @options.quiet
        LOG.level = Logger::ERROR
      else
        # The default is WARN
        LOG.level = Logger::WARN
      end

      # arguments then the pscheck command itself
      process_arguments
      process_command
    else
      output_usage
    end

  end

  protected

  def parsed_options?
    # specify options
    opts = OptionParser.new
    opts.on('-h', '--help')        { output_help }
    opts.on('-V', '--verbose')     { @options.verbose = true }
    opts.parse!(@arguments) rescue return false
    process_options
    true
  end

  # Performs post-parse processing on options
  def process_options
    @options.verbose = false if @options.quiet
  end

  def output_options
    puts "Options:\n"

    @options.marshal_dump.each do |name, val|
      puts "  #{name} = #{val}"
    end
  end

  # True if required arguments were provided
  def arguments_valid?
    true if @arguments.length == 2
  end

  # Setup the arguments
  def process_arguments
    @directory1 = ARGV[0] if ARGV[0]
    @directory2 = ARGV[1] if ARGV[1]
  end

  def output_help
    puts version_text
    # RDoc::usage() #exits app
  end

  def output_usage
    # RDoc::usage('usage') # gets usage from comments above
  end

  def output_version
    puts version_text
    puts OptionParser::Version.join('.')
  end

  # This is where the Script actually does something
  def process_command
    LOG.info "========================= Checking Documents ========================= "
    check_efficently(@directory1/"documents.csv", @directory2/"documents.csv")
    
    LOG.info "========================= Checking Signatures ======================== "
    check_efficently(@directory1/"signatures.csv", @directory2/"signatures.csv")
    
    LOG.info "=============================== All Done ============================= "
    
  end
  
  # Check efficiently - load the fist into an array and then go down the second 
  def check_efficently(filepath1, filepath2)
    LOG.info "Parsing #{filepath1}"
    # Load the first CSV file into a Hash
    items = load_csv_to_hash(filepath1)

    LOG.info "Checking against #{filepath2}"
    # Now go through the 2nd file line by line, comparing anything we find
    CSV.foreach(filepath2) do |row|
      # The first entry is the key
      id = row[0]
      if !items.include?(id)
        LOG.error "Error - when parsing looking for DocID #{id} in the first report, couldn't find it in the second"
      else
        # Check the two arrays of document details are the same
        if items[id] == row
          LOG.info "DocID #{id} is identical - all OK"
          # Both copies are identical, so let's remove it from docs2
          items.delete(id)
        else
          LOG.error "Error - The two reports for DocID #{id} are different"
          LOG.error "  Copy 1 #{items[id].inspect}"
          LOG.error "  Copy 2 #{row.inspect}"
        end
      end
    end
    # We've now finished reading the file, so there should be nothing left in items
    if items.size > 0
      LOG.error "*** Found more documents in the 1strepository than we did in the first ***"
      LOG.error "Outputting the spare documents"
      items.each do |entry|
        LOG.error "  #{entry.inspect}"
      end
      LOG.error "-------------"
    end
    
  end
  
  # Simple utility to load one CSV into a hash of arrays
  def load_csv_to_hash(filepath)
    the_hash = {}
    CSV.foreach(filepath) do |row|
      the_hash[row[0]] = row
    end
    return the_hash
  end
    
end


# Extension to string
class String
  # / gives a pretty clear way to join path information
  def /(str_to_join)
    path = File.join(self, str_to_join)
    # if win32 switch / to \\
    path.gsub!(File::SEPARATOR, File::ALT_SEPARATOR || File::SEPARATOR) if is_windows?
    path
  end

  # switches \\ or \ to / for dir pattern search
  def to_pattern
    is_windows? ? self.gsub!(/\\|\\\\/,"/") : self
  end

end



# Use a variety of techniques to determine if we're on a Windows platform
def is_windows?
  return true if ENV['OS'] =~ /Windows/i 
  return true if RUBY_PLATFORM =~ /win32/i 
  return true if RUBY_PLATFORM =~ /mingw32/i 
  return true if RUBY_PLATFORM =~ /mswin/i 

  # If we got this far, assume we're on something other than Windows
  return false
end



# Create and run the application
comparer = RepositoryComparer.new(ARGV, STDIN)
comparer.run
