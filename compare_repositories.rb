#!/usr/bin/env ruby
#
# == Synopsis
#   Script to compmare the reports generated by the checker from the same repository
#   in two different places. Script will confirm
#        - All the documents on one server are on the other, with the same hashes
#        - All the documents on one server are on the other, with the same hashes
#
#   Note this requires the report files to be in .csv format. Using JSON would introduce a
#   Gem dependency , which we like to avoid
#
# == Examples
#
#     ruby compare_repositories.rb /path/to/reports/directory1 /path/to/reports/directory2
#
# == Usage
#   compare_repositories.rb [options] /path/to/reports/directory1 /path/to/reports/directory2
#
#   For help use: ruby compare_repositories.rb -h
#
# == Options
#   -h, --help          Displays help message
#
# == Author
#   Amphora Research Systems, Ltd.
#
# == Copyright
#   Copyright (c) 2012 Amphora Research Systems Ltd.
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# ================================================================================================================
# Yes, I know this could be more compact code, but I'm writing for transparency here... people reading this code
# might not be Ruby native
# ================================================================================================================


# Things we need to process command line arguments
require 'optparse'
require 'ostruct'

# For importing the .csv files
require 'csv'

# Logging
require 'logger'


# setup our logger STDOUT for now
LOG = Logger.new(STDOUT)
# Only report errors
LOG.level = Logger::ERROR

# This is pretty much copied from the pscheck.rb file
class RepositoryComparer
    attr_reader :options

    def initialize(arguments, stdin)
        @arguments = arguments
        @stdin = stdin

        # set defaults
        @options = OpenStruct.new

    end

    # Parse options, check arguments, then process the command
    def run
        if parsed_options? && arguments_valid?
            if @options.verbose
                LOG.level = Logger::INFO
            elsif @options.quiet
                LOG.level = Logger::ERROR
            else
                # The default is WARN
                LOG.level = Logger::WARN
            end

            # arguments then the pscheck command itself
            process_arguments
            process_command
        else
            output_usage
        end

    end

    protected

    def parsed_options?
        # specify options
        opts = OptionParser.new
        opts.on('-h', '--help') { output_help }
        opts.on('-V', '--verbose') { @options.verbose = true }
        opts.parse!(@arguments) rescue return false
        process_options
        true
    end

    # Performs post-parse processing on options
    def process_options
        @options.verbose = false if @options.quiet
    end

    def output_options
        puts "Options:\n"

        @options.marshal_dump.each do |name, val|
            puts "  #{name} = #{val}"
        end
    end

    # True if required arguments were provided
    def arguments_valid?
        true if @arguments.length == 2
    end

    # Setup the arguments
    def process_arguments
        @directory1 = ARGV[0] if ARGV[0]
        @directory2 = ARGV[1] if ARGV[1]
    end

    def output_help
        puts version_text
        # RDoc::usage() #exits app
    end

    def output_usage
        # RDoc::usage('usage') # gets usage from comments above
    end

    def output_version
        puts version_text
        puts OptionParser::Version.join('.')
    end

    # This is where the Script actually does something
    def process_command
        LOG.info "========================= Checking Documents ========================= "
        check_efficently(@directory1/"documents.csv", @directory2/"documents.csv")

        LOG.info "========================= Checking Signatures ======================== "
        check_efficently(@directory1/"signatures.csv", @directory2/"signatures.csv")

        LOG.info "=============================== All Done ============================= "

    end

    # Check efficiently - load the fist into an array and then go down the second
    def check_efficently(filepath1, filepath2)
        LOG.info "Parsing #{filepath1}"
        # Load the first CSV file into a Hash
        itemsReport1 = load_csv_to_hash(filepath1)

        itemsMissingFrom1 = []

        LOG.info "Checking against #{filepath2}"
        # Now go through the 2nd file line by line, comparing anything we find
        CSV.foreach(filepath2) do |row|
            id = row[0] # The first entry is the key

            if !itemsReport1.include?(id)
                LOG.info "Error - second report contains a DocID not found in the first: #{id}"
                itemsMissingFrom1 << row
            else
                # Check the two arrays of document details are the same
                if itemsReport1[id] == row
                    # Both copies are identical
                    LOG.info "DocID #{id} is identical - all OK"
                else
                    LOG.error "Error - The two reports for DocID #{id} are different"
                    LOG.error "  Copy 1 #{itemsReport1[id].inspect}"
                    LOG.error "  Copy 2 #{row.inspect}"
                end
            end

            # the line has been either verified or added to itemsMissingFrom1
            itemsReport1.delete(id)
        end

        # We've now finished reading the file, so there should be nothing left in items
        if !itemsReport1.empty?
            LOG.error "*** Found #{itemsReport1.size} documents in the first repository not present in the second one ***"
            LOG.error "Outputting the spare documents from "+ filepath1
            itemsReport1.each do |entry|
                LOG.error "  #{entry.inspect}"
            end
            LOG.error "-------------"
        end

        if !itemsMissingFrom1.empty?
            LOG.error "*** Found #{itemsMissingFrom1.size} documents in the second repository not present in the first one ***"
            LOG.error "Outputting the spare documents from "+ filepath2
            itemsMissingFrom1.each do |entry|
                LOG.error "  #{entry.inspect}"
            end
            LOG.error "-------------"
        end
    end

    # Simple utility to load one CSV into a hash of arrays
    def load_csv_to_hash(filepath)
        the_hash = {}
        CSV.foreach(filepath) do |row|
            the_hash[row[0]] = row
        end
        return the_hash
    end

end


# Extension to string
class String
    # / gives a pretty clear way to join path information
    def /(str_to_join)
        path = File.join(self, str_to_join)
        # if win32 switch / to \\
        path.gsub!(File::SEPARATOR, File::ALT_SEPARATOR || File::SEPARATOR) if is_windows?
        path
    end

    # switches \\ or \ to / for dir pattern search
    def to_pattern
        is_windows? ? self.gsub!(/\\|\\\\/, "/") : self
    end

end


# Use a variety of techniques to determine if we're on a Windows platform
def is_windows?
    return true if ENV['OS'] =~ /Windows/i
    return true if RUBY_PLATFORM =~ /win32/i
    return true if RUBY_PLATFORM =~ /mingw32/i
    return true if RUBY_PLATFORM =~ /mswin/i

    # If we got this far, assume we're on something other than Windows
    return false
end


# Create and run the application
comparer = RepositoryComparer.new(ARGV, STDIN)
comparer.run
